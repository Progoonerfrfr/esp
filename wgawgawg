--// Structure taken from https://github.com/shlexware/Sirius/blob/request/library/sense/source.lua (they have like the most optimized structure) | Elements have been rewritten --\\

-- Services
local run_service = game:GetService("RunService");
local players = game:GetService("Players");
local workspace = game:GetService("Workspace");
local tween_service = game:GetService("TweenService");

-- Variables
local local_player = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local params = RaycastParams.new(); do
    params.FilterType = Enum.RaycastFilterType.Blacklist;
    params.FilterDescendantsInstances = {camera};
end

-- Locals
local floor = math.floor;
local vector2_new = Vector2.new;
local round = math.round;
local clear = table.clear;
local find = table.find;

-- Methods
local find_first_child = workspace.FindFirstChild;
local find_first_child_of_class = workspace.FindFirstChildOfClass;
local ray_cast = workspace.Raycast;
local lerp_color = Color3.new().Lerp;
local lerp2 = Vector2.zero.Lerp;

-- Constants
local CORNER_BOXES_BOTTOM_OFFSET = vector2_new(0, 1);
local HEALTH_BAR_OFFSET = vector2_new(4, 0);
local HEALTH_BAR_OUTLINE_OFFSET = vector2_new(0, 1);
local VISIBILITY_CACHE_TIME = 0.1; -- Cache visibility for 0.1 seconds

-- Tween Configuration
local FADE_SPEED = 0.1; -- How fast the fade happens (0.1 is smooth, higher is faster)

-- Skeleton connections
local SKELETON_CONNECTIONS = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"},
};

-- Functions
local function world_to_screen(world)
    local screen, on_screen = camera.WorldToViewportPoint(camera, world);
    return vector2_new(screen.X, screen.Y), on_screen, screen.Z;
end

-- ESP Object
local esp_object = {};
esp_object.__index = esp_object;

function esp_object.new(player, interface)
    local self = setmetatable({}, esp_object);
    self.player = assert(player, "Missing argument #1 (Player expected)");
    self.interface = assert(interface, "Missing argument #2 (table expected)");
    self:Construct();
    return self;
end

function esp_object:_create(class, properties)
    local drawing = Drawing.new(class);

    for property, value in properties do
        pcall(function()
            drawing[property] = value;
        end)
    end

    self.bin[#self.bin + 1] = drawing;
    return drawing;
end

function esp_object:Construct()
    self.char_cache = {};
    self.child_count = 0;
    self.bin = {};
    self.visual_health = 0; -- Added for tweening
    self.visibility_cache = {
        is_visible = false,
        last_check = 0
    };
    self.smooth_alpha = 1; -- For fade animations
    self.in_range = true; -- Track if currently in max distance
    
    -- Create highlight for chams
    self.highlight = Instance.new("Highlight");
    self.highlight.Adornee = nil;
    self.highlight.FillTransparency = 0.5;
    self.highlight.OutlineTransparency = 1;
    self.highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
    self.highlight.Enabled = false;
    self.highlight.Parent = game:GetService("CoreGui");
    
    self.drawings = {
        visible = {
            box_corners = {
                top_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                top_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                top_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                top_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                bottom_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                bottom_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                bottom_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                bottom_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),

                top_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                top_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                top_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                top_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                bottom_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                bottom_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                bottom_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                bottom_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
            },

            box_outline = self:_create("Square", { Thickness = 3, Visible = false, Filled = false}),
            box = self:_create("Square", { Thickness = 1, Visible = false, Filled = false}),
            box_fill = self:_create("Square", { Thickness = 1, Visible = false, Filled = true}),

            healthbar_outline = self:_create("Line", { Thickness = 3, Visible = false}),
            health_bar = self:_create("Line", { Thickness = 1.5, Visible = false}),

            health_visual_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            name_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            weapon_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            distance_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            
            head_dot_outline = self:_create("Circle", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0), Filled = false}),
            head_dot = self:_create("Circle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = false}),

            offscreen_arrow = self:_create("Triangle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = true}),
        },
        
        skeleton = {}
    };

    -- Create skeleton lines
    for i = 1, #SKELETON_CONNECTIONS do
        self.drawings.skeleton[i] = {
            outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
            line = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) })
        };
    end

    self.render_connection = run_service.Heartbeat:Connect(function()
        self:Update();
        self:Render();
    end)
end

function esp_object:Destruct()
    self.render_connection:Disconnect();

    for i = 1, #self.bin do
        self.bin[i]:Remove();
    end

    if self.highlight then
        self.highlight:Destroy();
    end

    clear(self);
end

function esp_object:CheckVisibility()
    local current_time = tick();
    
    -- Use cached result if still valid
    if current_time - self.visibility_cache.last_check < VISIBILITY_CACHE_TIME then
        return self.visibility_cache.is_visible;
    end
    
    -- Perform new visibility check
    local is_visible = false;
    if self.character and self.character:FindFirstChild("HumanoidRootPart") then
        local root_pos = self.character.HumanoidRootPart.Position;
        local camera_pos = camera.CFrame.Position;
        local direction = (root_pos - camera_pos).Unit * (root_pos - camera_pos).Magnitude;
        
        local ray_result = ray_cast(workspace, camera_pos, direction, params);
        
        if ray_result then
            local hit_character = ray_result.Instance:FindFirstAncestorOfClass("Model");
            is_visible = hit_character == self.character;
        else
            is_visible = true;
        end
    end
    
    -- Update cache
    self.visibility_cache.is_visible = is_visible;
    self.visibility_cache.last_check = current_time;
    
    return is_visible;
end

function esp_object:Update()
    local interface = self.interface;
    local player = self.player;
    local character = interface.get_character(player);

    params.FilterDescendantsInstances = interface.get_ignorelist();
    self.options = interface.team_settings[interface.is_friendly(player) and "friendly" or "enemy"];
    self.character = character;
    self.health, self.max_health = interface.get_health(player);
    self.weapon = interface.get_weapon(player);
    self.name = player.Name;
    self.enabled = self.options.enabled and character and not (#interface.whitelist > 0 and not find(interface.whitelist, player.UserId));

    local head = self.enabled and find_first_child(character, "Head");
    local humanoid_root_part = self.enabled and find_first_child(character, "HumanoidRootPart");

    if (not head) or (not humanoid_root_part) then
        self.char_cache = {};
        self.on_screen = false;
        
        if self.highlight then
            self.highlight.Enabled = false;
            self.highlight.Adornee = nil;
        end
        
        return;
    end

    local root_position = humanoid_root_part.Position - Vector3.new(0, 0.35, 0);
    local screen_position, on_screen, depth = world_to_screen(root_position);

    self.on_screen = on_screen;
    self.distance = depth;

    -- Handle Distance Fade Logic
    if (interface.shared_settings.limit_distance) then
        local max_dist = interface.shared_settings.max_distance;
        -- Check if currently within valid range
        local currently_in_range = depth <= max_dist;

        if currently_in_range ~= self.in_range then
            -- If state changed, we want to fade
            -- We handle the fading in Render loop by updating smooth_alpha
        end
        self.in_range = currently_in_range;
    else
        self.in_range = true;
    end

    if (interface.shared_settings.limit_distance and depth > interface.shared_settings.max_distance) then
        -- We do NOT set on_screen to false here anymore. 
        -- We keep on_screen true so the render loop draws them, 
        -- but the alpha will be 0.
    end
    
    -- Recalculate on_screen status for purely occlusion/camera reasons
    -- But we still need to know if it's actually on the monitor to hide it if alpha > 0 but off screen
    if not on_screen then
        -- Keep offscreen logic for arrow
    end

    -- Calculate Arrow if off screen
    if not on_screen and humanoid_root_part then
        local viewport_size = camera.ViewportSize;
        local center = vector2_new(viewport_size.X / 2, viewport_size.Y / 2);
        
        local direction = (screen_position - center).Unit;
        local angle = math.atan2(direction.Y, direction.X);
        
        -- Position arrow at edge of screen
        local edge_distance = math.min(viewport_size.X, viewport_size.Y) * 0.45;
        local arrow_pos = center + direction * edge_distance;
        
        self.offscreen_arrow_position = arrow_pos;
        self.offscreen_arrow_rotation = angle;
    end

    -- Logic to calculate box positions if we were to draw them
    -- We need these positions even if fading out so it doesn't "snap" to center
    if (on_screen) then
        local scale = (humanoid_root_part.Size.Y * camera.ViewportSize.Y) / ((2 * depth * math.tan(math.rad(camera.FieldOfView) / 2)) * 1.5);
        
        local height = 4 * scale;
        local width = 2.5 * scale;
    
        local top_left = vector2_new(round(screen_position.X - (width / 2)), round(screen_position.Y - (height / 2)));
        local bottom_right = vector2_new(round(screen_position.X + (width / 2)), round(screen_position.Y + (height / 2)));
    
        self.corners = {
            top_left = top_left,
            bottom_right = bottom_right,
            bottom_left = vector2_new(top_left.X, bottom_right.Y),
            top_right = vector2_new(bottom_right.X, top_left.Y)
        };
        
        -- Head position for head dot
        if head then
            local head_pos, head_on_screen = world_to_screen(head.Position);
            self.head_position = head_pos;
            self.head_on_screen = head_on_screen;
        end
    end
end

function esp_object:Render()
    -- 1. Calculate Alpha (Fade)
    -- Target is 1 if in range, 0 if out of range
    local target_alpha = (self.in_range and self.enabled) and 1 or 0;
    
    -- Smoothly interpolate alpha
    self.smooth_alpha = self.smooth_alpha + (target_alpha - self.smooth_alpha) * FADE_SPEED;

    -- Optimization: If alpha is extremely close to 0, we can effectively treat it as invisible for performance, 
    -- but to get the fade out effect, we must keep drawing until it hits 0.
    -- If alpha is 0 and not in range, we can fully hide.
    -- But for the fade IN effect, we start drawing when alpha > 0.01.
    
    -- We apply alpha to everything. If alpha is 0, everything is invisible.
    
    local on_screen = self.on_screen or false;
    local enabled = self.enabled or false;
    local visible = self.drawings.visible;
    local options = self.options;
    local corners = self.corners;

    -- Determine base visibility (boolean) for structure. 
    -- We use the current interpolated alpha to determine if we should strictly "hide" the drawing object completely
    -- or just set transparency. 
    -- Drawing objects have a "Transparency" property.
    -- However, Drawing Transparency goes from 0 (opaque) to 1 (invisible).
    
    -- If the player is OFF SCREEN (geometrically), we usually show the arrow. 
    -- If the player is ON SCREEN, we show boxes.
    
    -- NOTE: If on_screen is false, we should not draw boxes, only the arrow.
    -- If on_screen is true, we draw boxes, not arrow.
    
    -- Special handling for fade out:
    -- If player is out of range, smooth_alpha -> 0.
    -- We must apply smooth_alpha to the transparency of ALL active elements.
    
    -- Helper to apply transparency
    -- Transparency for Drawings: 0 = Visible, 1 = Invisible
    -- So we use self.smooth_alpha directly? No.
    -- If smooth_alpha is 1 (fully visible), Transparency should be 0.
    -- If smooth_alpha is 0 (fully invisible), Transparency should be 1.
    local draw_transparency = 1 - self.smooth_alpha;

    -- If we are essentially invisible, we can force Visible = false to save performance, 
    -- BUT for the fade effect to work, we need Visible = true while Transparency is transitioning.
    -- Only when transparency is basically 1 can we turn off Visible.
    
    local is_effectively_visible = self.smooth_alpha > 0.01;
    local is_geometrically_visible = on_screen; -- Actually on screen (not behind camera)
    
    -- -- Boxes (Only if geometrically on screen)
    local show_boxes = is_geometrically_visible and is_effectively_visible;
    
    -- -- Arrow (Only if geometrically OFF screen)
    -- Note: If out of range, arrow should also fade out.
    local show_arrow = (not is_geometrically_visible) and is_effectively_visible;

    -- -- Chams (Can be seen even if off screen, but usually toggleable)
    local show_chams = is_effectively_visible; -- Chams usually work regardless of camera view, but let's tie it to existence

    -- Apply to Boxes
    do
        local box_type = options.box_type or "box";
        
        -- Box
        do
            local box = visible.box;
            local box_outline = visible.box_outline;
            local box_fill = visible.box_fill;

            -- Base Visibility
            box.Visible = show_boxes and options.box_type == "box";
            box_outline.Visible = box.Visible;
            box_fill.Visible = show_boxes and options.box_type == "box" and options.box_fill;

            if (box_type == "box" and (box.Visible or box_fill.Visible)) then
                local pos = corners.top_left;
                local size = corners.bottom_right - pos;
                
                box.Position = pos;
                box.Size = size;
                box.Color = options.box_color;
                box.Transparency = draw_transparency;

                box_outline.Position = box.Position;
                box_outline.Size = box.Size;
                box_outline.Color = Color3.fromRGB(0, 0, 0);
                box_outline.Transparency = draw_transparency;
                
                if box_fill.Visible then
                    box_fill.Position = pos;
                    box_fill.Size = size;
                    box_fill.Color = options.box_fill_color;
                    box_fill.Transparency = options.box_fill_transparency + (draw_transparency * (1 - options.box_fill_transparency)); -- Blend
                end
            end
        end

        -- Corner
        do
            local box_corners = visible.box_corners;

            for index, object in box_corners do
                -- Determine color (outline vs fill)
                if (not string.find(index, "outline")) then
                    object.Color = options.box_color;
                end

                object.Visible = show_boxes and options.box_type == "corner";
                if object.Visible then
                    object.Transparency = draw_transparency;
                end
            end
        
            if (box_type == "corner" and show_boxes) then
                local position = corners.top_left + (corners.bottom_right - corners.top_left) / 2;
                local width = (corners.bottom_right.X - corners.top_left.X) / 2;
                local height = (corners.bottom_right.Y - corners.top_left.Y) / 2;
            
                local corner_length = math.clamp(1 / self.distance * 750, 1, 300);

                local top_left_position = vector2_new(floor(position.X - width), floor(position.Y - height));
                local top_right_position = vector2_new(floor(position.X + width), floor(position.Y - height ));
                local bottom_left_position = vector2_new(floor(position.X - width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
                local bottom_right_position = vector2_new(floor(position.X + width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
            
                -- Elements (Inner)
                local top_left_vertical = box_corners.top_left_vertical;
                top_left_vertical.From = top_left_position;
                top_left_vertical.To = vector2_new(top_left_position.X, top_left_position.Y + corner_length);
                
                local top_left_horizontal = box_corners.top_left_horizontal;
                top_left_horizontal.From = top_left_position;
                top_left_horizontal.To = vector2_new(top_left_position.X + corner_length, top_left_position.Y);
                
                local top_right_vertical = box_corners.top_right_vertical;
                top_right_vertical.From = top_right_position;
                top_right_vertical.To = vector2_new(top_right_position.X, top_right_position.Y + corner_length);
                
                local top_right_horizontal = box_corners.top_right_horizontal;
                top_right_horizontal.From = top_right_position;
                top_right_horizontal.To = vector2_new(top_right_position.X - corner_length, top_right_position.Y);
                
                local bottom_left_vertical = box_corners.bottom_left_vertical;
                bottom_left_vertical.From = bottom_left_position;
                bottom_left_vertical.To = vector2_new(bottom_left_position.X, bottom_left_position.Y - corner_length);
                
                local bottom_left_horizontal = box_corners.bottom_left_horizontal;
                bottom_left_horizontal.From = bottom_left_position;
                bottom_left_horizontal.To = vector2_new(bottom_left_position.X + corner_length, bottom_left_position.Y)
                
                local bottom_right_vertical = box_corners.bottom_right_vertical;
                bottom_right_vertical.From = vector2_new(bottom_right_position.X, bottom_right_position.Y + 1);
                bottom_right_vertical.To = vector2_new(bottom_right_position.X, bottom_right_position.Y - corner_length);
                
                local bottom_right_horizontal = box_corners.bottom_right_horizontal;
                bottom_right_horizontal.From = bottom_right_position;
                bottom_right_horizontal.To = vector2_new(bottom_right_position.X - corner_length, bottom_right_position.Y);
            
                -- Outline
                do
                        local top_right_vertical_outline = box_corners.top_right_vertical_outline;
                        top_right_vertical_outline.From = vector2_new(top_right_vertical.From.X, top_right_vertical.From.Y - 1.2);
                        top_right_vertical_outline.To = vector2_new(top_right_vertical.To.X, top_right_vertical.To.Y + 1);

                        local bottom_right_horizontal_outline = box_corners.bottom_right_horizontal_outline;
                        bottom_right_horizontal_outline.From = vector2_new(bottom_right_horizontal.From.X + 1.2, bottom_right_horizontal.From.Y);
                        bottom_right_horizontal_outline.To = vector2_new(bottom_right_horizontal.To.X - 1, bottom_right_horizontal.To.Y);

                        local bottom_right_vertical_outline = box_corners.bottom_right_vertical_outline;
                        bottom_right_vertical_outline.From = vector2_new(bottom_right_vertical.From.X, bottom_right_vertical.From.Y);
                        bottom_right_vertical_outline.To = vector2_new(bottom_right_vertical.To.X, bottom_right_vertical.To.Y - 1);

                        local top_right_horizontal_outline = box_corners.top_right_horizontal_outline;
                        top_right_horizontal_outline.From = vector2_new(top_right_horizontal.From.X, top_right_horizontal.From.Y)
                        top_right_horizontal_outline.To = vector2_new(top_right_horizontal.To.X - 1, top_right_horizontal.To.Y);

                        local top_left_horizontal_outline = box_corners.top_left_horizontal_outline;
                        top_left_horizontal_outline.From = vector2_new(top_left_horizontal.From.X - 1, top_left_horizontal.From.Y);
                        top_left_horizontal_outline.To = vector2_new(top_left_horizontal.To.X + 1, top_left_horizontal.To.Y);

                        local top_left_vertical_outline = box_corners.top_left_vertical_outline;
                        top_left_vertical_outline.From = vector2_new(top_left_vertical.From.X, top_left_vertical.From.Y);
                        top_left_vertical_outline.To = vector2_new(top_left_vertical.To.X, top_left_vertical.To.Y + 1);

                        local bottom_left_horizontal_outline = box_corners.bottom_left_horizontal_outline;
                        bottom_left_horizontal_outline.From = vector2_new(bottom_left_horizontal.From.X - 1, bottom_left_horizontal.From.Y);
                        bottom_left_horizontal_outline.To = vector2_new(bottom_left_horizontal.To.X + 1, bottom_left_horizontal.To.Y);

                        local bottom_left_vertical_outline = box_corners.bottom_left_vertical_outline;
                        bottom_left_vertical_outline.From = vector2_new(bottom_left_vertical.From.X, bottom_left_vertical.From.Y);
                        bottom_left_vertical_outline.To = vector2_new(bottom_left_vertical.To.X, bottom_left_vertical.To.Y - 1);
                end
            end
        end
    end

    -- Healthbar
    do
        local health_bar = visible.health_bar;

        -- Base visibility
        health_bar.Visible = show_boxes and options.health_bar;
        visible.healthbar_outline.Visible = health_bar.Visible;

        if (health_bar.Visible) then
            -- Tween Logic
            local lerp_speed = 0.15; -- Adjust this value for smoother/faster animation
            self.visual_health = self.visual_health + (self.health - self.visual_health) * lerp_speed;

            local bar_from = corners.top_left - HEALTH_BAR_OFFSET
            local bar_to = corners.bottom_left - HEALTH_BAR_OFFSET
        
            health_bar.To = bar_to
            health_bar.From = lerp2(bar_to, bar_from, self.visual_health / self.max_health)
            health_bar.Color = (options.dynamic_color and lerp_color(options.dying_color, options.healthy_color, self.visual_health / self.max_health)) or options.health_bar_color
            health_bar.Transparency = draw_transparency; -- APPLY FADE
        
            local healthbar_outline = visible.healthbar_outline
            healthbar_outline.To = bar_to + HEALTH_BAR_OUTLINE_OFFSET
            healthbar_outline.From = bar_from - HEALTH_BAR_OUTLINE_OFFSET
            healthbar_outline.Color = Color3.fromRGB(0, 0, 0)
            healthbar_outline.Transparency = draw_transparency; -- APPLY FADE
        end

        -- Health Text
        do
            local health_text = visible.health_visual_text;
            health_text.Visible = show_boxes and options.health_text and health_bar.Visible;

            if (health_text.Visible) then
                health_text.Text = math.floor(self.health + 0.5);
                health_text.Color = options.health_text_color;
                health_text.Transparency = draw_transparency; -- APPLY FADE

                health_text.Position = health_bar.From + Vector2.new(-13, -3);
            end
        end
    end

    -- Name
    do
        local name = visible.name_text;
        name.Visible = show_boxes and options.name_text;

        if (name.Visible) then
            name.Text = self.name;
            name.Color = Color3.new(1, 1, 1);
            name.Transparency = draw_transparency; -- APPLY FADE
            name.Position = Vector2.new(corners.top_left.X + ((corners.bottom_right.X - corners.top_left.X) / 2), corners.top_left.Y - 15) - Vector2.new(0, 2);
        end
    end

    -- Weapon
    do
        local weapon = visible.weapon_text;
        weapon.Visible = show_boxes and options.weapon_text;

        if (weapon.Visible) then
            weapon.Text = self.weapon;
            weapon.Color = Color3.new(1, 1, 1);
            weapon.Transparency = draw_transparency; -- APPLY FADE
            weapon.Position = Vector2.new(corners.top_left.X + ((corners.bottom_right.X - corners.top_left.X) / 2), corners.bottom_right.Y) + Vector2.new(0, 2);
        end
    end

    -- Distance
    do
        local distance = visible.distance_text;
        distance.Visible = show_boxes and options.distance_text;

        if (distance.Visible) then
            distance.Text = math.floor(self.distance) .. "s";
            distance.Color = options.distance_text_color;
            distance.Transparency = draw_transparency; -- APPLY FADE
            
            local y_offset = options.weapon_text and 17 or 2;
            distance.Position = Vector2.new(corners.top_left.X + ((corners.bottom_right.X - corners.top_left.X) / 2), corners.bottom_right.Y) + Vector2.new(0, y_offset);
        end
    end

    -- Head Dot
    do
        local head_dot = visible.head_dot;
        local head_dot_outline = visible.head_dot_outline;
        
        head_dot.Visible = show_boxes and options.head_dot and self.head_on_screen;
        head_dot_outline.Visible = head_dot.Visible;

        if (head_dot.Visible) then
            local radius = math.clamp(1000 / self.distance, 3, 15);
            
            head_dot.Position = self.head_position;
            head_dot.Radius = radius;
            head_dot.Color = options.head_dot_color;
            head_dot.Transparency = draw_transparency; -- APPLY FADE
            
            head_dot_outline.Position = self.head_position;
            head_dot_outline.Radius = radius;
            head_dot_outline.Color = Color3.fromRGB(0, 0, 0);
            head_dot_outline.Transparency = draw_transparency; -- APPLY FADE
        end
    end

    -- Skeleton
    do
        -- Skeleton usually is visible even if boxes aren't, but let's tie it to show_boxes (on screen + in range)
        local skeleton_visible = show_boxes and options.skeleton;
        
        for i = 1, #SKELETON_CONNECTIONS do
            local connection = SKELETON_CONNECTIONS[i];
            local drawing_pair = self.drawings.skeleton[i];
            
            drawing_pair.line.Visible = false;
            drawing_pair.outline.Visible = false;
            
            if skeleton_visible and self.character then
                local part1 = find_first_child(self.character, connection[1]);
                local part2 = find_first_child(self.character, connection[2]);
                
                if part1 and part2 then
                    local pos1, on_screen1 = world_to_screen(part1.Position);
                    local pos2, on_screen2 = world_to_screen(part2.Position);
                    
                    if on_screen1 and on_screen2 then
                        drawing_pair.outline.Visible = true;
                        drawing_pair.outline.From = pos1;
                        drawing_pair.outline.To = pos2;
                        drawing_pair.outline.Color = Color3.fromRGB(0, 0, 0);
                        drawing_pair.outline.Transparency = draw_transparency; -- APPLY FADE
                        
                        drawing_pair.line.Visible = true;
                        drawing_pair.line.From = pos1;
                        drawing_pair.line.To = pos2;
                        drawing_pair.line.Color = options.skeleton_color;
                        drawing_pair.line.Transparency = draw_transparency; -- APPLY FADE
                    end
                end
            end
        end
    end

    -- Off-screen Indicator
    do
        local arrow = visible.offscreen_arrow;
        arrow.Visible = show_arrow and options.offscreen_arrow and self.offscreen_arrow_position;

        if (arrow.Visible) then
            local arrow_size = 15;
            local angle = self.offscreen_arrow_rotation;
            
            -- Calculate triangle points
            local tip = self.offscreen_arrow_position;
            local base_left = tip + vector2_new(
                math.cos(angle + 2.5) * arrow_size,
                math.sin(angle + 2.5) * arrow_size
            );
            local base_right = tip + vector2_new(
                math.cos(angle - 2.5) * arrow_size,
                math.sin(angle - 2.5) * arrow_size
            );
            
            arrow.PointA = tip;
            arrow.PointB = base_left;
            arrow.PointC = base_right;
            arrow.Color = options.offscreen_arrow_color;
            arrow.Transparency = draw_transparency; -- APPLY FADE
        end
    end

    -- Chams (Highlight)
    do
        if self.highlight then
            -- Chams visibility logic: enabled + in range
            -- Note: Chams don't have a "Transparency" property on the instance itself that acts like opacity 
            -- in the same way (they have FillTransparency).
            -- We can map draw_transparency (0..1) to FillTransparency (0..1).
            -- If draw_transparency is 0 (visible), FillTransparency should be options setting (e.g. 0.5).
            -- If draw_transparency is 1 (invisible), FillTransparency should be 1.
            
            self.highlight.Enabled = enabled and options.chams and is_effectively_visible;
            
            if self.highlight.Enabled then
                self.highlight.Adornee = self.character;
                
                -- Use cached visibility check
                local is_visible = self:CheckVisibility();
                
                -- Set colors based on visibility
                if is_visible then
                    self.highlight.FillColor = options.chams_visible_color;
                else
                    self.highlight.FillColor = options.chams_occluded_color;
                end

                -- Calculate Fill Transparency based on fade
                -- Base transparency is usually 0.5. We want to lerp to 1.
                local base_fill_transp = 0.5;
                self.highlight.FillTransparency = base_fill_transp + (draw_transparency * (1 - base_fill_transp));
            else
                self.highlight.Adornee = nil;
            end
        end
    end
end

-- interface
local esp = {
    loaded = false,
    object_cache = {},
    whitelist = {},
    shared_settings = {
        limit_distance = false,
        max_distance = 100,
    },
    team_settings = {
        enemy = {
            enabled = false,

            box = false,
            box_type = "box", -- corner & box
            box_fill = false,

            weapon_text = false,
            health_text = false,
            name_text = false,
            distance_text = false,

            health_bar = false,
            dynamic_color = false,

            chams = false,
            head_dot = false,
            skeleton = false,
            offscreen_arrow = false,

            box_color = Color3.fromRGB(255, 255, 255),
            box_fill_color = Color3.fromRGB(255, 255, 255),
            box_fill_transparency = 0.5,
            weapon_text_color = Color3.fromRGB(255, 255, 255),
            name_text_color = Color3.fromRGB(255, 255, 255),
            distance_text_color = Color3.fromRGB(255, 255, 255),

            health_text_color = Color3.fromRGB(255, 255, 255),
            health_bar_color = Color3.fromRGB(255, 255, 255),

            chams_visible_color = Color3.fromRGB(0, 255, 0),
            chams_occluded_color = Color3.fromRGB(255, 0, 0),

            head_dot_color = Color3.fromRGB(255, 255, 255),
            skeleton_color = Color3.fromRGB(255, 255, 255),
            offscreen_arrow_color = Color3.fromRGB(255, 255, 255),

            dying_color = Color3.fromRGB(255, 0, 0),
            healthy_color = Color3.fromRGB(0, 255, 0),
        },
        friendly = {
            enabled = false,

            box = false,
            box_type = "box", -- corner & box
            box_fill = false,

            weapon_text = false,
            health_text = false,
            name_text = false,
            distance_text = false,

            health_bar = false,
            dynamic_color = false,

            chams = false,
            head_dot = false,
            skeleton = false,
            offscreen_arrow = false,

            box_color = Color3.fromRGB(255, 255, 255),
            box_fill_color = Color3.fromRGB(255, 255, 255),
            box_fill_transparency = 0.5,
            weapon_text_color = Color3.fromRGB(255, 255, 255),
            name_text_color = Color3.fromRGB(255, 255, 255),
            distance_text_color = Color3.fromRGB(255, 255, 255),

            health_text_color = Color3.fromRGB(255, 255, 255),
            health_bar_color = Color3.fromRGB(255, 255, 255),

            chams_visible_color = Color3.fromRGB(0, 255, 0),
            chams_occluded_color = Color3.fromRGB(255, 0, 0),

            head_dot_color = Color3.fromRGB(255, 255, 255),
            skeleton_color = Color3.fromRGB(255, 255, 255),
            offscreen_arrow_color = Color3.fromRGB(255, 255, 255),

            dying_color = Color3.fromRGB(255, 0, 0),
            healthy_color = Color3.fromRGB(0, 255, 0),
        },
    }
};

function esp.Load()
    local function create_object(player)
        esp.object_cache[player] = {
            esp_object.new(player, esp),
        };
    end

    local function remove_object(player)
        local object = esp.object_cache[player];
        if object then
            for i = 1, #object do
                object[i]:Destruct();
            end

            esp.object_cache[player] = nil;
        end
    end

    local plrs = players:GetPlayers();
    
    for i = 2, #plrs do
        create_object(plrs[i]);
    end

    esp.playerAdded = players.PlayerAdded:Connect(create_object);
    esp.playerRemoving = players.PlayerRemoving:Connect(remove_object);
    esp.loaded = true;
end

function esp.Unload()
    for index, object in esp.object_cache do
        for i = 1, #object do
            object[i]:Destruct();
        end

        esp.object_cache[index] = nil;
    end

    esp.playerAdded:Disconnect();
    esp.playerRemoving:Disconnect();
    esp.loaded = false;
end

-- game specific functions
function esp.get_ignorelist()
    return {local_player.Character, camera};
end

function esp.get_weapon(player)
    local character = player.Character;

    if (not character) then
        return "Nothing";
    end

    for index, value in character:GetChildren() do
        if value.Name ~= "HolsterModel" and value:IsA("Model") and value.Name ~= "Hair" and (value:FindFirstChild("Detail") or value:FindFirstChild("Main") or value:FindFirstChild("Handle") or value:FindFirstChild("Attachments") or value:FindFirstChild("ArrowAttach") or value:FindFirstChild("Attach")) and value.PrimaryPart then
            return value.Name
        end
    end

    return "Nothing";
end

function esp.is_friendly(player)
    return player.Team and player.Team == local_player.Team;
end

function esp.get_character(player)
    return player.Character;
end

function esp.get_health(player)
    local character = player and esp.get_character(player);
    local humanoid = character and find_first_child_of_class(character, "Humanoid");

    if (humanoid) then
        return humanoid.Health, humanoid.MaxHealth;
    end

    return 100, 100;
end

--esp.Load();
return esp;
