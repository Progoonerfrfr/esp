--// Optimized ESP Structure with Smooth Animations & Visual Upgrades --\\

-- Services
local run_service = game:GetService("RunService");
local players = game:GetService("Players");
local workspace = game:GetService("Workspace");

-- Variables
local local_player = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local params = RaycastParams.new(); do
    params.FilterType = Enum.RaycastFilterType.Blacklist;
    params.FilterDescendantsInstances = {camera};
end

-- Locals
local floor = math.floor;
local vector2_new = Vector2.new;
local round = math.round;
local clear = table.clear;
local find = table.find;
local clamp = math.clamp;
local lerp = function(a, b, t) return a + (b - a) * t; end;

-- Methods
local find_first_child = workspace.FindFirstChild;
local find_first_child_of_class = workspace.FindFirstChildOfClass;
local ray_cast = workspace.Raycast;
local lerp_color = Color3.new().Lerp;

-- Constants
local CORNER_BOXES_BOTTOM_OFFSET = vector2_new(0, 1);
local HEALTH_BAR_OFFSET = vector2_new(4, 0); -- Offset from box
local FADE_SPEED = 0.15; -- How fast it appears/disappears (lower is smoother)
local HEALTH_BAR_SPEED = 0.1; -- How fast the health bar moves
local GHOST_HEALTH_SPEED = 0.05; -- How fast the damage indicator moves (slower = better effect)

-- Skeleton connections
local SKELETON_CONNECTIONS = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"},
};

-- Functions
local function world_to_screen(world)
    local screen, on_screen = camera.WorldToViewportPoint(camera, world);
    return vector2_new(screen.X, screen.Y), on_screen, screen.Z;
end

-- ESP Object
local esp_object = {};
esp_object.__index = esp_object;

function esp_object.new(player, interface)
    local self = setmetatable({}, esp_object);
    self.player = assert(player, "Missing argument #1 (Player expected)");
    self.interface = assert(interface, "Missing argument #2 (table expected)");
    self:Construct();
    return self;
end

function esp_object:_create(class, properties)
    local drawing = Drawing.new(class);
    for property, value in properties do
        pcall(function() drawing[property] = value; end)
    end
    self.bin[#self.bin + 1] = drawing;
    return drawing;
end

function esp_object:Construct()
    self.bin = {};
    
    -- Animation States (0 = Invisible, 1 = Visible)
    self.opacity = 0; 
    self.health_percent = 1;
    self.ghost_health_percent = 1; -- For damage effect

    -- Create highlight for chams
    self.highlight = Instance.new("Highlight");
    self.highlight.Adornee = nil;
    self.highlight.FillTransparency = 0.5;
    self.highlight.OutlineTransparency = 0; -- Outline looks better for chams
    self.highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
    self.highlight.Enabled = false;
    self.highlight.Parent = game:GetService("CoreGui");
    
    self.drawings = {
        visible = {
            box_corners = {
                top_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                top_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                top_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                top_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                bottom_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                bottom_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                
                bottom_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
                bottom_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),

                top_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                top_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                top_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                top_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                bottom_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                bottom_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                
                bottom_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
                bottom_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
            },

            box_outline = self:_create("Square", { Thickness = 3, Visible = false, Filled = false}),
            box = self:_create("Square", { Thickness = 1, Visible = false, Filled = false}),
            box_fill = self:_create("Square", { Thickness = 1, Visible = false, Filled = true}),

            -- Health Bar Background (Black bar)
            healthbar_background = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0,0,0)}),
            -- Ghost Health (Damage indicator)
            health_bar_ghost = self:_create("Line", { Thickness = 1.5, Visible = false, Color = Color3.fromRGB(255, 50, 50)}),
            -- Main Health
            health_bar = self:_create("Line", { Thickness = 1.5, Visible = false}),

            health_visual_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            name_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            weapon_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            distance_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
            
            head_dot_outline = self:_create("Circle", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0), Filled = false}),
            head_dot = self:_create("Circle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = false}),

            offscreen_arrow = self:_create("Triangle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = true}),
            
            -- Tracer (Line from bottom of screen to player)
            tracer = self:_create("Line", { Thickness = 1, Color = Color3.fromRGB(255, 255, 255), Transparency = 0.5 }),
            tracer_outline = self:_create("Line", { Thickness = 3, Color = Color3.fromRGB(0, 0, 0) }),
        },
        
        skeleton = {}
    };

    -- Create skeleton lines
    for i = 1, #SKELETON_CONNECTIONS do
        self.drawings.skeleton[i] = {
            outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
            line = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) })
        };
    end

    self.render_connection = run_service.RenderStepped:Connect(function(delta)
        self:Update(delta);
        self:Render();
    end)
end

function esp_object:Destruct()
    self.render_connection:Disconnect();
    for i = 1, #self.bin do self.bin[i]:Remove(); end
    if self.highlight then self.highlight:Destroy(); end
    clear(self);
end

function esp_object:Update(delta)
    local interface = self.interface;
    local player = self.player;
    local character = interface.get_character(player);

    params.FilterDescendantsInstances = interface.get_ignorelist();
    self.options = interface.team_settings[interface.is_friendly(player) and "friendly" or "enemy"];
    self.character = character;
    self.real_health, self.max_health = interface.get_health(player);
    self.weapon = interface.get_weapon(player);
    self.name = player.Name;
    
    -- Check if ESP should be logically visible
    -- We check settings, character existence, and whitelist
    local should_be_enabled = self.options.enabled and character and not (#interface.whitelist > 0 and not find(interface.whitelist, player.UserId));
    
    -- Handle Smooth Fade (Opacity)
    local target_opacity = should_be_enabled and 1 or 0;
    
    -- Smooth lerp for opacity
    if self.opacity < target_opacity then
        self.opacity = clamp(self.opacity + (delta / FADE_SPEED), 0, 1);
    elseif self.opacity > target_opacity then
        self.opacity = clamp(self.opacity - (delta / FADE_SPEED), 0, 1);
    end

    local head = should_be_enabled and find_first_child(character, "Head");
    local humanoid_root_part = should_be_enabled and find_first_child(character, "HumanoidRootPart");

    if (not head) or (not humanoid_root_part) then
        self.on_screen = false;
        self.highlight.Enabled = false;
        self.highlight.Adornee = nil;
        return;
    end

    local root_position = humanoid_root_part.Position - Vector3.new(0, 0.35, 0);
    local screen_position, on_screen, depth = world_to_screen(root_position);

    self.on_screen = on_screen;
    self.distance = depth;

    if (interface.shared_settings.limit_distance and depth > interface.shared_settings.max_distance) then
        self.on_screen = false;
    end

    if (self.on_screen) then
        local scale = (humanoid_root_part.Size.Y * camera.ViewportSize.Y) / ((2 * depth * math.tan(math.rad(camera.FieldOfView) / 2)) * 1.5);
        local height = 4 * scale;
        local width = 2.5 * scale;
    
        local top_left = vector2_new(round(screen_position.X - (width / 2)), round(screen_position.Y - (height / 2)));
        local bottom_right = vector2_new(round(screen_position.X + (width / 2)), round(screen_position.Y + (height / 2)));
    
        self.corners = {
            top_left = top_left,
            bottom_right = bottom_right,
            bottom_left = vector2_new(top_left.X, bottom_right.Y),
            top_right = vector2_new(bottom_right.X, top_left.Y),
            center = vector2_new(round(screen_position.X), round(screen_position.Y))
        };
        
        if head then
            local head_pos, head_on_screen = world_to_screen(head.Position);
            self.head_position = head_pos;
            self.head_on_screen = head_on_screen;
        end
    else
        if humanoid_root_part then
            local viewport_size = camera.ViewportSize;
            local center = vector2_new(viewport_size.X / 2, viewport_size.Y / 2);
            local direction = (screen_position - center).Unit;
            local angle = math.atan2(direction.Y, direction.X);
            local edge_distance = math.min(viewport_size.X, viewport_size.Y) * 0.45;
            local arrow_pos = center + direction * edge_distance;
            self.offscreen_arrow_position = arrow_pos;
            self.offscreen_arrow_rotation = angle;
        end
    end
    
    -- Health Animation Logic
    local target_health_percent = self.real_health / self.max_health;
    self.health_percent = lerp(self.health_percent, target_health_percent, delta / HEALTH_BAR_SPEED);
    self.ghost_health_percent = lerp(self.ghost_health_percent, self.health_percent, delta / GHOST_HEALTH_SPEED);
end

function esp_object:Render()
    -- Only render if opacity is visible enough (optimization + clean cutoff)
    if self.opacity < 0.01 then
        -- Force hide all if invisible
        for _, v in pairs(self.drawings.visible) do
            if typeof(v) == "table" then
                for _, v2 in pairs(v) do v2.Visible = false; end
            else
                v.Visible = false;
            end
        end
        for _, v in pairs(self.drawings.skeleton) do
            v.line.Visible = false; v.outline.Visible = false;
        end
        self.highlight.Enabled = false;
        return;
    end

    local on_screen = self.on_screen;
    local options = self.options;
    local corners = self.corners;
    
    -- Global transparency for fade effect
    local fade_transparency = 1 - self.opacity;

    -- Boxes
    do
        local box_type = options.box_type or "box";
        local vis = on_screen and options.box;
        
        local box = self.drawings.visible.box;
        local box_outline = self.drawings.visible.box_outline;
        local box_fill = self.drawings.visible.box_fill;
        
        box.Visible = vis and box_type == "box";
        box_outline.Visible = box.Visible;
        box_fill.Visible = vis and box_type == "box" and options.box_fill;

        if box.Visible then
            local pos = corners.top_left;
            local size = corners.bottom_right - pos;
            
            box.Position = pos; box.Size = size; box.Color = options.box_color; box.Transparency = fade_transparency;
            box_outline.Position = pos; box_outline.Size = size; box_outline.Transparency = fade_transparency;
            
            if box_fill.Visible then
                box_fill.Position = pos; box_fill.Size = size; box_fill.Color = options.box_fill_color;
                box_fill.Transparency = 1 - (1 - options.box_fill_transparency) * self.opacity;
            end
        end

        -- Corner Box
        local box_corners = self.drawings.visible.box_corners;
        for _, object in box_corners do
            object.Transparency = fade_transparency;
            object.Visible = vis and box_type == "corner";
        end
    
        if (box_type == "corner" and vis) then
            local pos = corners.top_left;
            local size = corners.bottom_right - pos;
            local position = pos + size / 2;
            local width = size.X / 2;
            local height = size.Y / 2;
            local corner_length = clamp(1 / self.distance * 750, 2, size.X/3);

            local top_left_position = vector2_new(floor(position.X - width), floor(position.Y - height));
            local top_right_position = vector2_new(floor(position.X + width), floor(position.Y - height ));
            local bottom_left_position = vector2_new(floor(position.X - width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
            local bottom_right_position = vector2_new(floor(position.X + width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
        
            -- Set positions
            local function set_line(tbl, name, from, to)
                tbl[name].From = from; tbl[name].To = to;
            end
            set_line(box_corners, "top_left_vertical", top_left_position, vector2_new(top_left_position.X, top_left_position.Y + corner_length));
            set_line(box_corners, "top_left_horizontal", top_left_position, vector2_new(top_left_position.X + corner_length, top_left_position.Y));
            set_line(box_corners, "top_right_vertical", top_right_position, vector2_new(top_right_position.X, top_right_position.Y + corner_length));
            set_line(box_corners, "top_right_horizontal", top_right_position, vector2_new(top_right_position.X - corner_length, top_right_position.Y));
            set_line(box_corners, "bottom_left_vertical", bottom_left_position, vector2_new(bottom_left_position.X, bottom_left_position.Y - corner_length));
            set_line(box_corners, "bottom_left_horizontal", bottom_left_position, vector2_new(bottom_left_position.X + corner_length, bottom_left_position.Y));
            set_line(box_corners, "bottom_right_vertical", bottom_right_position, vector2_new(bottom_right_position.X, bottom_right_position.Y - corner_length));
            set_line(box_corners, "bottom_right_horizontal", bottom_right_position, vector2_new(bottom_right_position.X - corner_length, bottom_right_position.Y));

            -- Outlines (Black)
            local function set_outline(tbl, name, from, to)
                local o = tbl[name.."_outline"]; o.From = from; o.To = to;
            end
            set_outline(box_corners, "top_right_vertical", vector2_new(box_corners.top_right_vertical.From.X, box_corners.top_right_vertical.From.Y - 1), vector2_new(box_corners.top_right_vertical.To.X, box_corners.top_right_vertical.To.Y + 1));
            set_outline(box_corners, "top_right_horizontal", vector2_new(box_corners.top_right_horizontal.From.X, box_corners.top_right_horizontal.From.Y), vector2_new(box_corners.top_right_horizontal.To.X - 1, box_corners.top_right_horizontal.To.Y));
            set_outline(box_corners, "bottom_left_vertical", vector2_new(box_corners.bottom_left_vertical.From.X, box_corners.bottom_left_vertical.From.Y), vector2_new(box_corners.bottom_left_vertical.To.X, box_corners.bottom_left_vertical.To.Y - 1));
            set_outline(box_corners, "bottom_left_horizontal", vector2_new(box_corners.bottom_left_horizontal.From.X - 1, box_corners.bottom_left_horizontal.From.Y), vector2_new(box_corners.bottom_left_horizontal.To.X + 1, box_corners.bottom_left_horizontal.To.Y));
            set_outline(box_corners, "top_left_vertical", vector2_new(box_corners.top_left_vertical.From.X, box_corners.top_left_vertical.From.Y), vector2_new(box_corners.top_left_vertical.To.X, box_corners.top_left_vertical.To.Y + 1));
            set_outline(box_corners, "top_left_horizontal", vector2_new(box_corners.top_left_horizontal.From.X - 1, box_corners.top_left_horizontal.From.Y), vector2_new(box_corners.top_left_horizontal.To.X + 1, box_corners.top_left_horizontal.To.Y));
            set_outline(box_corners, "bottom_right_vertical", vector2_new(box_corners.bottom_right_vertical.From.X, box_corners.bottom_right_vertical.From.Y), vector2_new(box_corners.bottom_right_vertical.To.X, box_corners.bottom_right_vertical.To.Y - 1));
            set_outline(box_corners, "bottom_right_horizontal", vector2_new(box_corners.bottom_right_horizontal.From.X + 1, box_corners.bottom_right_horizontal.From.Y), vector2_new(box_corners.bottom_right_horizontal.To.X - 1, box_corners.bottom_right_horizontal.To.Y));
        end
    end

    -- Healthbar (Animated)
    do
        local vis = on_screen and options.health_bar;
        local bg = self.drawings.visible.healthbar_background;
        local ghost = self.drawings.visible.health_bar_ghost;
        local main = self.drawings.visible.health_bar;

        bg.Visible = vis;
        ghost.Visible = vis;
        main.Visible = vis;

        if vis then
            local bar_from = corners.top_left - HEALTH_BAR_OFFSET;
            local bar_to = corners.bottom_left - HEALTH_BAR_OFFSET;
        
            -- Background (Full length black bar)
            bg.From = bar_from - Vector2.new(1,0); bg.To = bar_to + Vector2.new(1,0); bg.Transparency = fade_transparency;

            -- Ghost (Damage Indicator) - Slower lerp
            local ghost_x = lerp(bar_to.X, bar_from.X, self.ghost_health_percent);
            ghost.From = vector2_new(bar_to.X, bar_to.Y); ghost.To = vector2_new(ghost_x, bar_to.Y);
            ghost.Color = options.ghost_color or Color3.fromRGB(200, 50, 50);
            ghost.Transparency = fade_transparency + 0.2; -- Slightly transparent

            -- Main Health - Faster lerp
            local main_x = lerp(bar_to.X, bar_from.X, self.health_percent);
            main.From = vector2_new(bar_to.X, bar_to.Y); main.To = vector2_new(main_x, bar_to.Y);
            main.Color = (options.dynamic_color and lerp_color(options.dying_color, options.healthy_color, self.health_percent)) or options.health_bar_color;
            main.Transparency = fade_transparency;

            -- Text
            local health_text = self.drawings.visible.health_visual_text;
            health_text.Visible = vis and options.health_text;
            if health_text.Visible then
                health_text.Text = tostring(round(self.real_health));
                health_text.Color = options.health_text_color;
                health_text.Transparency = fade_transparency;
                health_text.Position = main.From + Vector2.new(-13, -3);
            end
        end
    end

    -- Tracers
    do
        local tracer_vis = on_screen and options.tracer;
        local tracer = self.drawings.visible.tracer;
        local tracer_outline = self.drawings.visible.tracer_outline;

        tracer.Visible = tracer_vis;
        tracer_outline.Visible = tracer_vis;

        if tracer_vis then
            local bottom_pos = vector2_new(camera.ViewportSize.X / 2, camera.ViewportSize.Y);
            local target_pos = corners.bottom_middle or (corners.bottom_left + (corners.bottom_right - corners.bottom_left)/2);
            
            tracer.From = bottom_pos; tracer.To = target_pos;
            tracer.Color = options.tracer_color;
            tracer.Transparency = fade_transparency * 0.8; -- Tracers usually look better slightly transparent

            tracer_outline.From = bottom_pos; tracer_outline.To = target_pos;
            tracer_outline.Transparency = fade_transparency;
        end
    end

    -- Text Elements (Name, Dist, Weapon)
    local function render_text(obj, txt, col, pos)
        obj.Visible = on_screen and options[obj.Name:gsub("_text","").."_text"]; -- hacky mapping but works for name_text, distance_text etc
        if obj.Visible then
            obj.Text = txt; obj.Color = col; obj.Position = pos; obj.Transparency = fade_transparency;
        end
    end

    render_text(self.drawings.visible.name_text, self.name, options.name_text_color, Vector2.new(corners.center.X, corners.top_left.Y - 15));
    render_text(self.drawings.visible.weapon_text, self.weapon, options.weapon_text_color, Vector2.new(corners.center.X, corners.bottom_right.Y + 2));
    
    local dist_y_offset = options.weapon_text and 17 or 2;
    render_text(self.drawings.visible.distance_text, math.floor(self.distance).."m", options.distance_text_color, Vector2.new(corners.center.X, corners.bottom_right.Y + dist_y_offset));

    -- Head Dot
    do
        local hd = self.drawings.visible.head_dot;
        local hdo = self.drawings.visible.head_dot_outline;
        local vis = on_screen and options.head_dot and self.head_on_screen;
        
        hd.Visible = vis; hdo.Visible = vis;
        if vis then
            local radius = clamp(1000 / self.distance, 2, 10);
            hd.Position = self.head_position; hd.Radius = radius; hd.Color = options.head_dot_color; hd.Transparency = fade_transparency;
            hdo.Position = self.head_position; hdo.Radius = radius; hdo.Transparency = fade_transparency;
        end
    end

    -- Skeleton
    do
        local skel_vis = on_screen and options.skeleton;
        for i, connection in SKELETON_CONNECTIONS do
            local dp = self.drawings.skeleton[i];
            dp.line.Visible = false; dp.outline.Visible = false;
            
            if skel_vis and self.character then
                local p1 = find_first_child(self.character, connection[1]);
                local p2 = find_first_child(self.character, connection[2]);
                if p1 and p2 then
                    local s1, v1 = world_to_screen(p1.Position);
                    local s2, v2 = world_to_screen(p2.Position);
                    if v1 and v2 then
                        dp.line.Visible = true; dp.line.From = s1; dp.line.To = s2; dp.line.Color = options.skeleton_color; dp.line.Transparency = fade_transparency;
                        dp.outline.Visible = true; dp.outline.From = s1; dp.outline.To = s2; dp.outline.Transparency = fade_transparency;
                    end
                end
            end
        end
    end

    -- Offscreen Arrow
    do
        local arr = self.drawings.visible.offscreen_arrow;
        arr.Visible = not on_screen and options.offscreen_arrow and self.offscreen_arrow_position;
        if arr.Visible then
            local tip = self.offscreen_arrow_position;
            local angle = self.offscreen_arrow_rotation;
            local s = 12;
            arr.PointA = tip;
            arr.PointB = tip + vector2_new(math.cos(angle + 2.5) * s, math.sin(angle + 2.5) * s);
            arr.PointC = tip + vector2_new(math.cos(angle - 2.5) * s, math.sin(angle - 2.5) * s);
            arr.Color = options.offscreen_arrow_color; arr.Transparency = fade_transparency;
        end
    end

    -- Chams
    if self.highlight then
        self.highlight.Enabled = on_screen and options.chams;
        if self.highlight.Enabled then
            self.highlight.Adornee = self.character;
            -- Simple raycast for visibility
            local root = self.character:FindFirstChild("HumanoidRootPart");
            if root then
                local ray = ray_cast(workspace, camera.CFrame.Position, (root.Position - camera.CFrame.Position).Unit * 1000, params);
                local is_visible = ray and (ray.Instance:IsDescendantOf(self.character) or ray.Instance:FindFirstAncestorOfClass("Model") == self.character) or (ray == nil);
                
                self.highlight.FillColor = is_visible and options.chams_visible_color or options.chams_occluded_color;
                self.highlight.FillTransparency = lerp(1, 0.5, self.opacity);
                self.highlight.OutlineTransparency = lerp(1, 0, self.opacity);
            end
        else
            self.highlight.Adornee = nil;
        end
    end
end

-- Interface
local esp = {
    loaded = false, object_cache = {}, whitelist = {},
    shared_settings = { limit_distance = false, max_distance = 250, },
    team_settings = {
        enemy = {
            enabled = false,
            box = false, box_type = "corner", box_fill = false,
            tracer = false, tracer_color = Color3.fromRGB(255, 255, 255),
            weapon_text = true, health_text = true, name_text = true, distance_text = true,
            health_bar = true, dynamic_color = true,
            chams = false, head_dot = false, skeleton = false, offscreen_arrow = false,
            box_color = Color3.fromRGB(255, 50, 50), box_fill_color = Color3.fromRGB(255, 50, 50), box_fill_transparency = 0.7,
            weapon_text_color = Color3.fromRGB(200, 200, 200), name_text_color = Color3.fromRGB(255, 255, 255), distance_text_color = Color3.fromRGB(200, 200, 200),
            health_text_color = Color3.fromRGB(255, 255, 255), health_bar_color = Color3.fromRGB(50, 255, 50),
            ghost_color = Color3.fromRGB(150, 0, 0),
            chams_visible_color = Color3.fromRGB(50, 255, 50), chams_occluded_color = Color3.fromRGB(255, 50, 50),
            head_dot_color = Color3.fromRGB(255, 255, 255), skeleton_color = Color3.fromRGB(255, 255, 255),
            offscreen_arrow_color = Color3.fromRGB(255, 255, 255),
            dying_color = Color3.fromRGB(255, 0, 0), healthy_color = Color3.fromRGB(0, 255, 0),
        },
        friendly = {
            enabled = false,
            box = false, box_type = "corner", box_fill = false,
            tracer = false, tracer_color = Color3.fromRGB(50, 255, 50),
            weapon_text = true, health_text = true, name_text = true, distance_text = true,
            health_bar = true, dynamic_color = true,
            chams = false, head_dot = false, skeleton = false, offscreen_arrow = false,
            box_color = Color3.fromRGB(50, 255, 50), box_fill_color = Color3.fromRGB(50, 255, 50), box_fill_transparency = 0.7,
            weapon_text_color = Color3.fromRGB(200, 200, 200), name_text_color = Color3.fromRGB(255, 255, 255), distance_text_color = Color3.fromRGB(200, 200, 200),
            health_text_color = Color3.fromRGB(255, 255, 255), health_bar_color = Color3.fromRGB(50, 255, 50),
            ghost_color = Color3.fromRGB(150, 0, 0),
            chams_visible_color = Color3.fromRGB(50, 255, 50), chams_occluded_color = Color3.fromRGB(255, 50, 50),
            head_dot_color = Color3.fromRGB(255, 255, 255), skeleton_color = Color3.fromRGB(255, 255, 255),
            offscreen_arrow_color = Color3.fromRGB(255, 255, 255),
            dying_color = Color3.fromRGB(255, 0, 0), healthy_color = Color3.fromRGB(0, 255, 0),
        },
    }
};

function esp.Load()
    local function create_object(player)
        esp.object_cache[player] = { esp_object.new(player, esp) };
    end
    local function remove_object(player)
        local object = esp.object_cache[player];
        if object then for i = 1, #object do object[i]:Destruct(); end esp.object_cache[player] = nil; end
    end
    for i = 2, #players:GetPlayers() do create_object(players:GetPlayers()[i]); end
    esp.playerAdded = players.PlayerAdded:Connect(create_object);
    esp.playerRemoving = players.PlayerRemoving:Connect(remove_object);
    esp.loaded = true;
end

function esp.Unload()
    for _, object in esp.object_cache do
        for i = 1, #object do object[i]:Destruct(); end
    end
    if esp.playerAdded then esp.playerAdded:Disconnect(); end
    if esp.playerRemoving then esp.playerRemoving:Disconnect(); end
    esp.loaded = false;
end

function esp.get_ignorelist() return {local_player.Character, camera}; end
function esp.get_weapon(player)
    local char = player.Character; if not char then return "Nothing"; end
    for _, v in char:GetChildren() do
        if v.Name ~= "HolsterModel" and v:IsA("Model") and v.Name ~= "Hair" and (v:FindFirstChild("Detail") or v:FindFirstChild("Main") or v:FindFirstChild("Handle") or v:FindFirstChild("Attachments") or v:FindFirstChild("ArrowAttach") or v:FindFirstChild("Attach")) and v.PrimaryPart then
            return v.Name
        end
    end
    return "Nothing";
end
function esp.is_friendly(player) return player.Team and player.Team == local_player.Team; end
function esp.get_character(player) return player.Character; end
function esp.get_health(player)
    local char = player and esp.get_character(player);
    local hum = char and find_first_child_of_class(char, "Humanoid");
    if hum then return hum.Health, hum.MaxHealth; end
    return 100, 100;
end

return esp;
